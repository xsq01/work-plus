# 重载和重写的区别

## 重写

- 主要发生在接口和子类、父类之间

- 实现接口时，**必须**要重写其内部方法，对于子类和父类之间不是必须重写的，但是对于抽象方法是必须重写。

- 重写的规则

  - 参数列表与被重写方法的参数列表必须完全相同。

  - 返回类型与被重写方法的返回类型可以不相同，但必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。

  - 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。

  - 父类的成员方法只能被它的子类重写。

  - 声明为 final 的方法不能被重写。

  - 声明为 static 的方法不能被重写，但是能够被再次声明。

  - 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。

  - 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。

  - 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。

  - 构造方法不能被重写。

  - 如果不能继承一个类，则不能重写该类的方法。

    ```java
    class son extends father{
    // 解释了返回类型与被重写方法的返回类型可以不相同，但必须是父类返回值的派生类  
        @Override
        public B test(){
            return new B();
        }
        static void test1(){
            System.out.println("son static");
        }
    }
    class father{
        final  void test2(){
            System.out.println("father final");
        }
        static  void test1(){
            System.out.println("father static");
        }
        public A test(){
            return new A();
        }
    }
    class A{
        public void test(){
            System.out.println("A");
        }
    }
    class B extends A{
        public void test(){
            System.out.println("B");
        }
    }
    ```

## 重载

- 重载发生在一个类里面，方法名字相同，参数不同。返回类型可以相同也可以不同
- 重载规则
  - 被重载的方法必须改变参数列表(参数个数或类型不一样)；
  - 被重载的方法可以改变返回类型；
  - 被重载的方法可以改变访问修饰符；
  - 被重载的方法可以声明新的或更广的检查异常；
  - 方法能够在同一个类中或者在一个子类中被重载。
  - 无法以返回值类型作为重载函数的区分标准。

## 问题：重载和重写的区别，以及重载方法是否可以根据返回类型来调用

- 重载体现了多态性，重写表现在父类和子类之间的多态性
- 重载方法不能通过返回类型来调用，因为在调用目标方法时，无法指定返回值类型信息的，编译器并不知道调用那个方法